---
import { isBefore, eachDayOfInterval, endOfDay, isSameDay, isWithinInterval, addMinutes, startOfDay } from 'date-fns'
import locale from 'date-fns/locale/fi/index.js'
import { format } from 'date-fns-tz';
import { marked } from 'marked'

import BaseHead from "$/components/BaseHead.astro";
import { CheckPick } from '$/components/CheckPick';
import Icon from '$/components/Icon.astro';
import OrganizerMenu from '$/components/OrganizerMenu.astro';
import PageFooter from '$/components/PageFooter.astro';
import PageHeader from "$/components/PageHeader.astro";
import { getMemberIdFromCookie } from '$/lib/auth';
import { getLogger } from '$/lib/bugsnag';
import { meetupToZonedTime, toZonedTime } from '$/lib/date';
import { sql } from '$/lib/db'
import { getRegistrationCloseDate } from '$/lib/meetup';
import { formatPrettyReference } from '$/lib/reference';
import ErrorPage from '$/pages/404.astro'
import type { Meetup, Member, Place, Registration } from "$/types/db";

const opts = { locale, timeZone: 'Europe/Helsinki' }

const now = new Date()
const nowFinnish = toZonedTime(new Date())
const id = Math.round(Number(Astro.params.id))

const memberId = getMemberIdFromCookie(Astro.request.headers.get('cookie'))
const member = memberId != null ? (await sql<Member[]>`SELECT * FROM members WHERE id = ${memberId}`).pop() : undefined
const meetup = (id > 0 || undefined) && (await sql<Meetup[]>`SELECT * FROM meetups WHERE id = ${id}`).map(meetupToZonedTime).pop()

const place = meetup && (await sql<Place[]>`SELECT * FROM places WHERE id = ${meetup.placeId}`).pop()
const [{ name: organizerName }] =
	(meetup?.organizer === 'member' && await sql<{ name: string }[]>`SELECT publicname AS name FROM members WHERE id = ${meetup.memberId}`) ||
	(meetup?.organizer === 'organization' && meetup.organizationId && await sql<{ name: string }[]>`SELECT name AS name FROM organizations WHERE id = ${meetup.organizationId}`) ||
	[{ name: undefined }]

const registrations = await sql<Registration[]>`
	SELECT * FROM registrations
	WHERE "meetupId" = ${id}
	ORDER BY "isOrganizer" DESC,
		"cancelled" ASC NULLS FIRST,
		"confirmed" ASC NULLS LAST,
		"registered" ASC NULLS LAST,
		"id" ASC
`

const isOwner = meetup != null && member != null && meetup.memberId === member.id
const isOrganizer =
	meetup != null && member != null && registrations.some(reg => reg.isOrganizer && reg.memberId === member.id)
const hasAccess = isOwner || isOrganizer

const meetupInterval = (meetup && meetup.begin && meetup.end && { start: startOfDay(meetup.begin), end: endOfDay(meetup.end) }) || null
const meetupDays = meetupInterval ? eachDayOfInterval(meetupInterval) : []

const closeDate = getRegistrationCloseDate(meetup)
const isRegistrationOpen = meetup?.open != null && closeDate != null && isBefore(meetup.open, nowFinnish) && isBefore(nowFinnish, closeDate)
const isPost = Astro.request.method.toUpperCase() === 'POST'
const isSubmit = isRegistrationOpen && isPost

const memberRegs = isRegistrationOpen && member ? registrations.filter(registration => registration.memberId === member.id) : []

type RegLevelType = 'organizer' | 'cancelled' | 'confirmed' | 'registered' | 'added'

function getRegLevel(reg: Registration): RegLevelType {
	if (reg.isOrganizer) return 'organizer'
	if (reg.cancelled != null) return 'cancelled'
	if (reg.confirmed != null) return 'confirmed'
	if (reg.registered != null) return 'registered'
	return 'added'
}

type ErrorType = 'database-error'
type SuccessType = 'level-update-success' | 'no-level-to-update'

const errors = new Set<ErrorType>()
const success = new Set<SuccessType>()

if (isSubmit && member) {
	const formData = await Astro.request.formData()

	const levels = new Map<number, { prevLevel: RegLevelType, nextLevel: RegLevelType }>()
	const days = new Map<number, string[]>(memberRegs.map(reg => [reg.id, []]))

	for (let [key, value] of formData.entries()) {
		if (typeof value !== 'string') continue

		const item = /^level\[(\d+)\]$/.exec(key)
		if (item && levels.size < 6) {
			const [_, num] = item
			const id = Number(num)
			const oldReg = memberRegs.find((reg) => reg.id === id)
			if (oldReg) {
				if (value === 'cancelled' || value === 'confirmed' || value === 'registered') {
					const oldLevel = getRegLevel(oldReg)
					if (oldLevel !== value) levels.set(id, { prevLevel: oldLevel, nextLevel: value })
				}
			}
		}

		const dayItem = meetupInterval && !item && /^days\[(\d+)\]$/.exec(key)
		if (dayItem) {
			const [_, num] = dayItem
			const id = Number(num)
			if (/^\d\d\d\d-\d\d-\d\d$/.test(value)) {
				const day = new Date(value)
				if (isWithinInterval(day, meetupInterval)) {
					if (days.size < 6 || days.has(id)) {
						const arr = days.get(id) ?? []
						days.set(id, arr.concat(value))
					}
				}
			}
		}
	}

	if (levels.size === 0 && days.size === 0) {
		success.add('no-level-to-update')
	} else {
		try {
			if (days.size > 0) {
				const updates = (await sql.begin(sql => Array.from(days.entries()).map(
					([id, days]) => sql<Registration[]>`
						UPDATE registrations
						SET "days" = ${days.length < meetupDays.length ? days.join(' ') : null}
						WHERE "id" = ${id}
						RETURNING *
					`
				))).flat()

				if (updates.length === 0) {
					throw 'database-error'
				}

				updates.forEach(updated => {
					const regIndex = registrations.findIndex(reg => reg.id === updated.id)
					const memberRegIndex = memberRegs.findIndex(reg => reg.id === updated.id)
					registrations[regIndex] = updated
					memberRegs[memberRegIndex] = updated
				})
			}

			if (levels.size > 0) {
				const updates = (await sql.begin(sql => Array.from(levels.entries()).map(
					([id, { prevLevel, nextLevel }]) => {
						let fields: (
							| { cancelled: null | Date }
							| { confirmed: null | Date, cancelled: null | Date }
							| { registered: Date, confirmed: null | Date, cancelled: null | Date }
						) = { cancelled: null }

						if (prevLevel === 'added') {
							fields = { registered: now, cancelled: null }
						}

						if (nextLevel === 'registered') {
							fields = { ...fields, confirmed: null }
						} else if (nextLevel === 'confirmed') {
							fields = { ...fields, confirmed: now }
						} else if (nextLevel === 'cancelled') {
							fields = { ...fields, cancelled: now }
						}

						return sql<Registration[]>`
							UPDATE registrations
							SET ${sql(fields)}
							WHERE "id" = ${id}
							RETURNING *
						`
					})
				)).flat()

				if (updates.length === 0) {
					throw 'database-error'
				}

				updates.forEach(updated => {
					const regIndex = registrations.findIndex(reg => reg.id === updated.id)
					const memberRegIndex = memberRegs.findIndex(reg => reg.id === updated.id)
					registrations[regIndex] = updated
					memberRegs[memberRegIndex] = updated
				})
			}

			success.add('level-update-success')
		} catch (error) {
			if (typeof error === 'string') {
				errors.add(error as ErrorType)
			} else if (error instanceof Error) {
				getLogger().notify(error)
				errors.add('database-error')
			}
		}
	}
}

const registrationOpens = meetup && meetup.open != null && isBefore(nowFinnish, meetup.open) && format(meetup.open, `EEEE d.M.Y 'klo' H:mm`, opts)
const registrationCloseDate = meetup && meetup.begin ? meetup.end ? isSameDay(meetup.begin, meetup.end) ? addMinutes(meetup.begin, -5) : endOfDay(meetup.begin) : meetup.begin : null
const registrationCloses = registrationOpens && registrationCloseDate != null && isBefore(nowFinnish, registrationCloseDate) && format(registrationCloseDate, `EEEE d.M.Y 'klo' H:mm`, opts)

const meetupWasInThePast = meetup && (meetup.end == null || isBefore(meetup.end, nowFinnish))
const textRegister = meetupWasInThePast ? 'Saattoi osallistua' : 'Vahvistamatta'
const textConfirm = meetupWasInThePast ? 'Osallistui' : 'Osallistumassa'
const textCancel = meetupWasInThePast ? 'Ei osallistunut' : 'Perunut'
const textAdded = meetupWasInThePast ? 'Lisättiin' : 'Lisätty'

const dialog = new URL(Astro.request.url).searchParams.get('dialog')

if (member || dialog != null) {
	if (!isPost) {
		Astro.response.headers.set('Cache-Control', 'private, max-age=0')
	} else {
		Astro.response.headers.set('Cache-Control', 'no-cache')
	}
	Astro.response.headers.set('X-Robots-Tag', 'noindex')
} else if (isRegistrationOpen) {
	Astro.response.headers.set('Cache-Control', 'public, max-age=0')
} else {
	Astro.response.headers.set('Cache-Control', 'public, max-age=3600')
}

const breadcrumbs = meetup ? [
	{ href: '/', title: 'Etusivu' },
	{ href: `/meetups`, title: 'Miitit' },
	{ title: meetup.title }
] : []

---

{meetup ?

<html lang="fi">

<BaseHead title={meetup.title} description="Miitti" />

<body>
	<PageHeader breadcrumbs={breadcrumbs}>
		{hasAccess &&
		<OrganizerMenu meetupId={meetup.id} />}
	</PageHeader>

	<main id="main">
		{success.has('level-update-success') && <div>Osallistuminen päivitetty!</div>}
		{success.has('no-level-to-update') && <div>Osallistumistietoja ei tarvinnut päivittää.</div>}
		{errors.has('database-error') && <div>Odottamaton virhe: tietokannan päivittäminen ei onnistunut!</div>}
		{dialog === 'registration-success' && <div>Ilmoittautumisesi on otettu vastaan!</div>}
		{dialog === 'registration-updated' && <div>Ilmoittautumisesi päivitettiin!</div>}
		<h1 style="margin-bottom:0">{meetup.title}</h1>
		{organizerName && <div><small>Järjestäjä: <strong>{organizerName}</strong></small></div>}
		{memberRegs.length > 0 ? <div class="participated">
			<h2>Olet ilmoittautunut tähän tapahtumaan!</h2>
			<p>Voit päivittää tässä osallistumisesi niin kauan aikaa kuin ilmoittautuminen on auki.</p>
			<form action={`/meetups/view/${meetup.id}`} method="POST">
				<dl>
					{memberRegs.map(reg => {
					const regLevel = getRegLevel(reg)

					const regDates = reg.days && meetupInterval
					? reg.days
					.split(' ')
					.filter(date => /^\d\d\d\d-\d\d-\d\d$/.test(date))
					.map(date => new Date(date))
					.filter(date => isWithinInterval(date, meetupInterval))
					: []

					function inRegDates(date: Date) {
					return regDates.some(regDate => isSameDay(date, regDate))
					}

					return <div>
						<dt>{reg.publicname}</dt>
						<dd class="form-field" style="min-width:8.75rem">
							{regLevel==='organizer' ? <><strong>Järjestäjä</strong><br />Osallistuu</> :
							<label>
								Osallistuminen:
								<select name={`level[${reg.id}]`}>
									<option value="registered" selected={regLevel==='registered' }>
										Ei vahvistettu
									</option>
									<option value="confirmed" selected={regLevel==='confirmed' }>
										Osallistuu
									</option>
									<option value="cancelled" selected={regLevel==='cancelled' }>
										Ei osallistu
									</option>
								</select>
							</label>}
						</dd>
						{meetupInterval && <dd class="form-field reg-days">
							<span>Päivät jos osallistuu:</span><br />
							<span class="dayspicks">
								{meetupDays.map(date => {

								const ymd = format(date, 'yyyy-MM-dd' , opts)
								const checked = regLevel !== 'cancelled' && (reg.days == null || inRegDates(date))
								const title = format(date, 'EEEE d.M.yyyy' , opts)

								return <CheckPick checked={checked} name={`days[${reg.id}]`} title={title} value={ymd}>
									{format(date, 'EEEEEE', opts).toUpperCase()}
								</CheckPick>
								})}
							</span>
						</dd>}
					</div>})}
				</dl>
				<p class="form-field participation-button">
					<button type="submit" class="button-alt">
						<Icon href="/icons/refresh.svg" />
						Päivitä osallistuminen
					</button>
				</p>
			</form>
			{memberRegs[0].bankReference && <p>Viitenumero miitin maksamista
				varten:<br /><code>{formatPrettyReference(memberRegs[0].bankReference)}</code></p>}
			<p><a href={`/meetups/registration/${meetup.id}`}>Tarkasta ilmoittautumisen tiedot</a></p>
			<style>
				.dayspicks {
					display: flex;
					flex-wrap: wrap;
					gap: 0rem 0.25rem;
				}

				.participated {
					background: var(--bg-light-color-alt);
					border: thin solid var(--border-color);
					border-radius: 1rem;
					margin: 2rem 0;
					padding: 0 1.5rem;
				}

				.participation-button {
					text-align: right;
				}

				.participated dl {
					border-bottom: 3px double var(--border-color);
					border-top: 3px double var(--border-color);
					padding: 1rem 0;
				}

				.participated dl>div {
					align-items: center;
					display: flex;
					flex-wrap: wrap;
					gap: 0 1rem;
				}

				.participated dt {
					font-weight: bold;
					flex: 0 1 10rem;
					margin: 0;
					padding: 0;
				}

				.participated dd {
					margin: 0;
					padding: 0 0 1rem;
				}

				.reg-days {
					flex-grow: 1;
				}
			</style>
		</div> : isRegistrationOpen ? <p>
			<a class="button" href={`/meetups/registration/${meetup.id}`}>
				<Icon href="/icons/calendar.svg" />
				Ilmoittaudu tähän tapahtumaan
			</a>
		</p> : null}
		{!!meetup.description &&
		<div set:html={marked(meetup.description)} />}
		<h2>Muita yleisiä tietoja</h2>
		<ul>
			{registrationOpens && <li>Ilmoittautuminen aukeaa {registrationOpens}</li>}
			{registrationCloses && <li>Ilmoittautuminen sulkeutuu {registrationCloses}</li>}
			{meetup.isFree ? <li>Miitti on maksuton</li> : <li>Miitti ei ole ilmainen</li>}
			{meetup.enableDailyVisitors && <li>Miitissä saa käydä päivävierailulla</li>}
			{meetup.ageLimit > 0 && <li>Ikäraja: {meetup.ageLimit}</li>}
		</ul>
		{meetup.contactUrl && <p>Lisätietoja: <a
				href={`${meetup.contactUrl}`}>{decodeURIComponent(meetup.contactUrl)}</a></p>}
		{meetup.contactEmail && <p>Yhteydenotot: <a href={`mailto:${meetup.contactEmail}`}>{meetup.contactEmail}</a></p>
		}
		{place && <>
			<h2>Miittipaikka</h2>
			<p>
				<strong>{place.name}</strong>
				{place.streetAddress && <><br />{place.streetAddress}<br />{place.postalCode}{' '}{place.location}</>}
			</p>
			{meetup.beds > 0 && <p>Sänkypaikkoja: {meetup.beds} {meetup.enableCampingMembers && <span> (miitissä on
					mahdollista telttailla)</span>}</p>}
			{place.longitude ? <div class="map-browser">
				<button type="button" class="map-browser-button left" hidden>
					<Icon href="/icons/zoom-out.svg" />
				</button>
				<img class="map-browser-image" loading="lazy" alt="" src={`/places/map/${place.id}?zoom=3`} width="1305"
					height="748" />
				<button type="button" class="map-browser-button right" hidden>
					<Icon href="/icons/zoom-in.svg" />
				</button>
				<script type="module">
					const image = document.querySelector('.map-browser-image')
					const left = document.querySelector('.map-browser-button.left')
					const right = document.querySelector('.map-browser-button.right')
					left.removeAttribute('hidden')
					right.removeAttribute('hidden')
					right.disabled = true

					let zoomLevel = 3
					let loading = false

					function imageLoaded() {
						image.style = ''
					}

					image.onload = imageLoaded
					image.onerror = imageLoaded

					function setZoom(level) {
						zoomLevel = Math.min(Math.max(level, 0), 3)
						const url = new URL(image.src)
						url.searchParams.set('zoom', zoomLevel.toString())
						left.disabled = zoomLevel === 0
						right.disabled = zoomLevel === 3
						image.style = 'opacity:0.5'
						image.src = url
					}

					left.onclick = () => !loading && setZoom(zoomLevel - 1)
					right.onclick = () => !loading && setZoom(zoomLevel + 1)
				</script>
				<style>
					.map-browser {
						background-color: var(--border-color);
						box-shadow: 0 0 0 1px var(--border-color);
						position: relative;
					}

					button.map-browser-button {
						border-radius: 50%;
						min-width: 0;
						padding-inline: 0.5rem;
						position: absolute;
						top: 50%;
						transform: translateY(-50%);
					}

					.map-browser-button:active:not(:disabled) {
						transform: translateY(-50%) scale(1.25);
					}

					.left {
						left: 1rem;
					}

					.right {
						right: 1rem;
					}
				</style>
			</div> :
			<hr />}
			{place.description &&
			<div set:html={marked(place.description)} />}
			{place.howToGetThere && <>
				<h3>Saapumisohjeet</h3>
				<div set:html={marked(place.howToGetThere)} />
			</>}
		</>}
		{registrations.length > 0 && <>
			<h2>Ilmoittautuneet</h2>
			<table>
				<thead>
					<tr>
						<th>#</th>
						<th>Nimimerkki / julkinen nimi</th>
						<th>Osallistuminen</th>
					</tr>
				</thead>
				<tbody>
					{registrations.map((registration, index) => <tr>
						<td>{index + 1}</td>
						<td>{registration.publicname}</td>
						<td>{registration.isOrganizer && 'Järjestäjä' || (registration.cancelled && textCancel) ||
							(registration.confirmed && textConfirm) || (registration.registered && textRegister) ||
							textAdded}</td>
					</tr>)}
				</tbody>
			</table>
			<p>Ilmoittautuneiden järjestys riippuu siitä milloin he ovat vahvistaneet osallistuvansa.</p>
			<style>
				table {
					--odd-cell-color: var(--bg-light-color);
					--even-cell-color: var(--bg-light-color-alt);
					margin: 1rem -1rem;
				}

				td,
				th {
					padding: 0.25rem 0.5rem;
					text-align: left;
				}

				td:first-child,
				th:first-child {
					text-align: right;
				}

				tbody>tr:nth-child(odd)>td {
					background-color: var(--odd-cell-color);
				}
				tbody>tr:nth-child(even)>td {
					background-color: var(--even-cell-color);
				}
			</style>
		</>}
	</main>

	<PageFooter />
</body>

</html>
:
<ErrorPage />}
